#!/bin/bash

# Do not edit this file unless you know what you are doing

#==============================================================================
#title:         Build ROM
#description:   Menu which allows multiple items to be selected
#author:        Franco28
#created:       April 27 2019
#updated:       1.2 03-05-2019
#version:       1.0
#usage:         ./make
#help:          To make your own banner, go here: http://patorjk.com/software/taag/#p=display&h=0&v=0&f=ANSI%20Shadow&t=
#==============================================================================
#<!-- 
#
#     ____  _      __           __  __      _                           
#    / __ \(_)____/ /___  __   / / / /___  (_)________  _________  _____
#   / / / / / ___/ __/ / / /  / / / / __ \/ / ___/ __ \/ ___/ __ \/ ___/
#  / /_/ / / /  / /_/ /_/ /  / /_/ / / / / / /__/ /_/ / /  / / / (__  ) 
# /_____/_/_/   \__/\__, /   \____/_/ /_/_/\___/\____/_/  /_/ /_/____/  
#                 /____/     
#
#-->
#==============================================================================

#Colors
redt=$(tput setaf 1)
redb=$(tput setab 1)
greent=$(tput setaf 2)
greenb=$(tput setab 2)
yellowt=$(tput setaf 3)
yellowb=$(tput setab 3)
bluet=$(tput setaf 4)
blueb=$(tput setab 4)
magentat=$(tput setaf 5)
magentab=$(tput setab 5)
cyant=$(tput setaf 6)
cyanb=$(tput setab 6)
whiteb=$(tput setab 7)
bold=$(tput bold)
italic=$(tput sitm)
stand=$(tput smso)
underline=$(tput smul)
normal=$(tput sgr0)
NORMAL=`echo "\033[m"`
MENU=`echo "\033[36m"` # Blue
NUMBER=`echo "\033[33m"` # Yellow
FGRED=`echo "\033[41m"`
RED_TEXT=`echo "\033[31m"`
ENTER_LINE=`echo "\033[33m"`
COLOR='\033[01;31m' # Bold red
RESET='\033[00;00m' # Normal white
clears=$(tput clear) # Clear screen
makerom="makerom"
DIR="device/xiaomi"
builddir="vendor"
logs="makerom/logs"
tools="makerom/tools"
LOG_FILE="$logs/debug.out"
xiaomibuil1="makerom/source/makerom"
xiaomibuil2="makerom/source/makerom"
p7z="$tools/7z"
aapt="$tools/aapt"
usesudo2="sudo "
usesudo="sudo "
dlurl="https://bitbucket.org/Franco28/stockrom/downloads/" # DServer
export base=$(pwd)
export myuser=$(echo "$(whoami | gawk '{ print $1 }')")

###############################################################################################################################################

logfile() {
exec > >(tee -a ${LOG_FILE} )
exec 2> >(tee -a ${LOG_FILE} >&2)
cmp -s $xiaomibuil1 $xiaomibuil2 > /dev/null
}

buildwayne() {
    clear
    echo "$t_dubanner"
    if [[ -d "${builddir}" && ! -L "${builddir}" ]] ; then
    clear
    echo "$t_dubanner"
    source build/envsetup.sh                                            
    brunch du_wayne-userdebug                         # <<<<<<< DEV: Change this to your own ROM >>>>>>> #
    echo "$t_general_debug"                          
    echo ""
    read -p "$bold$redt$t_enter_exit$normal"
    else
    clear
    echo "$t_errorbanner"
    echo "Error can't find $builddir"
    echo ""
    read -p "$bold$redt$t_enter_exit$normal"
fi
}

buildjasmine() {
    clear
    echo "$t_dubanner"
    if [[ -d "${builddir}" && ! -L "${builddir}" ]] ; then
    clear
    echo "$t_dubanner"
    source build/envsetup.sh                                            
    brunch du_jasmine-userdebug                       # <<<<<<< DEV: Change this to your own ROM >>>>>>> # 
    echo "$t_general_debug"
    echo ""
    read -p "$bold$redt$t_enter_exit$normal"
    else
    clear
    echo "$t_errorbanner"
    echo "Error can't find $builddir"
    echo ""
    read -p "$bold$redt$t_enter_exit$normal"
fi
}

reposync() {
        clear
        echo -e "GET http://google.com HTTP/1.0\n\n" | nc google.com 80 > /dev/null 2>&1 
        if [ $? -eq 0 ]; then
        clear 
        echo "$t_bannerxiaomi"
        echo ""
        echo "$bold$redt$t_internet_status$normal $bold$redb$t_internet_status_on$normal" 
        echo ""
        else
        clear
        echo "$t_errorbanner"
        echo " "
        echo "$bold$redt$t_internet_status$normal $bold$redb$t_internet_status_off$normal" 
        echo " "
        echo "$bold$redt$t_internet_status_warn$normal" 
        echo " "
	read -p "$bold$redt$t_enter_exit$normal"
        exit
        fi
        clear
        if [[ -d "${DIR}" && ! -L "${DIR}" ]] ; then
        clear
        echo "$t_bannerxiaomi"   
        echo "$t_warning_sync"
        read -n 1 -p "$bold$redb$t_general_yes $normal" reply 
        echo " "
        echo " "
        if [[ $reply = "y" ]]; then
        clear
        echo "$t_syncbanner"
        repo sync -f --force-sync  
        echo ""
        echo "$t_general_debug" 
	read -p "$bold$redt$t_enter_exit$normal"
        fi
        else
        clear
        echo "$t_errorbanner"
        echo "$t_warning_sync2"
        echo ""
	read -p "$bold$redt$t_enter_exit$normal"
        fi
}

buildxk() {
    clear
    echo "$t_bannerxiaomi"
    export OUT_DIR_COMMON_BASE=/ssd/output
    rm -f /ssd/output/du/.lock
    source build/envsetup.sh
    lunch                                             # <<<<<<< DEV: Change this to your own ROM >>>>>>> #
    make bootimage -j4 
    echo ""
    echo "$t_general_debug" 
}

adb() {
if [[ -f "$adb" ]]; then
    clear
    echo "$t_bannerxiaomi"
    $adb logcat -d > $logs/logcat.txt 
    echo ""
    echo "$bold$redt$t_adb_succes$normal" 
    echo ""
    read -p "$bold$redt$t_enter_exit$normal"
    else
    clear
    echo "$t_errorbanner"
    echo "$bold$redt$t_adb_error$normal"
    echo ""
    read -p "$bold$redt$t_enter_exit$normal"
fi
}

cleanout() {
        clear
        echo "$t_bannerclean"
        echo "$bold$redb$t_general_question$normal" 
        echo " "
        read -n 1 -p "$bold$redb$t_general_yes$normal" reply
        echo " "
        echo " "
        if [[ $reply = "y" ]]; then
        clear
        echo "$t_bannerclean"
        echo "$t_general_clean_out"
        echo " "
        rm -r out 
        echo ""
        echo "$t_general_debug" 
        echo " "
	read -p "$bold$redt$t_enter_exit$normal"
        fi
}

cleancc() {
        clear
        echo "$t_bannerclean"
        echo "$t_general_ccache"
        echo " "
        ccache -C 
        echo ""
        echo "$t_general_debug" 
        echo ""
	read -p "$bold$redt$t_enter_exit$normal"
        echo " "
}

pause() {
  clear
  echo -e " "
  echo -n "$yellowt$bold$t_enter_anykey$normal"
  echo " "
  while true; do
    read -n1 -r
    clear
    echo " "
    echo -n "$yellowt$bold$t_enter_anykey$normal"
    echo " "
    [[ $REPLY == '' ]] && break
  done
  echo " "
  echo "$t_general_wait"
  echo " "
}

cpustat() {
df -PhT | awk '{print $3,$4,$5,$7}'
echo "*****************************"
top -b -n1 | grep "Cpu(s)" | awk '{print $2 + $4,$5}'
echo "*************************"
egrep 'processor|core id' /proc/cpuinfo
echo "***************"
free -m
echo "****************************" 
}

checkgit() {
clear
echo "$t_bannerxiaomi"
exitcode=0

root=`git rev-parse --show-toplevel`
echo "Root of repository: $root"
echo

cd "$root/makerom"
source_files=$(find . \( -name \*-sr -or -name \*makerom \) \
    -not -path "./source/*" \
    -not -path "./language/*")
header_files=$(find . \( -name \*-sr \) \
    -not -path "./source/*" \
    -not -path "./language/*")

# Check if there are header files without include guards
# The check can be disabled for any header file by inserting the exact text 'disable_include_guard_check',
# i.e. in a comment section.
files_without_include_guard=$(echo "$header_files" | xargs -I file sh -c \
    'guard=file;guard=${guard##*/};guard=${guard//./_};guard=${guard^^};grep -La "$guard\|#pragma once\|disable_include_guard_check" file')
if [[ -n "$files_without_include_guard" ]]; then
    echo
    echo "The following header files do not contain an include guard:"
    echo
    echo "$files_without_include_guard"
    exitcode=1
fi

# Check if source files contain tab characters.
files_with_tabs=$(echo "$source_files" | xargs grep -UPla '\t')
if [[ -n "$files_with_tabs" ]]; then
    echo
    echo "The following files contain tab characters:"
    echo
    echo "$files_with_tabs"
    exitcode=1
fi

# To replace all tabs: (warning! this introduces lf endings)
#echo "$files_with_tabs" | xargs sed -zi 's/\t/    /g'

# Check if all lines in source files end with a windows line ending
files_with_lf=$(echo "$source_files" | xargs grep -UPlazv '\r')
if [[ -n "$files_with_lf" ]]; then
    echo
    echo "The following files contain unix line endings:"
    echo
    echo "$files_with_lf"
    exitcode=1
fi

# To replace all lf with crlf:
#echo "$files_with_lf" | xargs unix2dos

# Check if all source files consist of ascii characters only.
files_with_non_ascii=$(echo "$source_files" | xargs grep -UPla '[\x80-\xFF]')
if [[ -n "$files_with_non_ascii" ]]; then
    echo
    echo "The following files contain non-ascii characters:"
    echo
    echo "$files_with_non_ascii"
    exitcode=1
fi


# Check if all source files consist of printable characters only.
# Note that we omit the -U flag for grep, such that carriage returns are ignored.
# Also note that we exclude tab characters, since we have a separate check for that.
lines_with_non_printable=$(echo "$source_files" | xargs grep -Pna '[^[:print:]\t]')
if [[ -n "$lines_with_non_printable" ]]; then
    echo
    echo "The following lines contain non-printable characters:"
    echo
    echo "$lines_with_non_printable"
    exitcode=1
fi


# Check if the length of all source lines are limited by some predefined constant.
# Both for readability, and to catch respective zos compilation errors early on.
files_with_too_long_lines=$(echo "$source_files" | xargs grep -la '.\{100\}')
if [[ -n "$files_with_too_long_lines" ]]; then
    echo
    echo "The following files contain lines that are too long:"
    echo
    echo "$files_with_too_long_lines"
    exitcode=1
fi

echo
[[ $exitcode -eq 0 ]] && echo Passed
[[ $exitcode -ne 0 ]] && echo Failed 
exit $exitcode
}

choosepr() {
        clear
        echo "$t_bannerxiaomi"
	local v e
	declare -i i=1
	v=$1
	shift 2
	for e in "$@"; do
		echo "$i) $e"
		i=i+1
	done
	if [[ $prchoice = "del" || $prchoice = "ext" ]]; then
		echo "${yellowt}m = $t_title_main"
	elif [[ $prchoice = "first" ]]; then
		echo "${yellowt}n = $t_menu_new$normal"
	elif [[ $prchoice = "plug" ]]; then
		echo "${yellowt}b = $t_menu_back$normal"
	fi
	echo "${magentat}q = $t_menu_quit$normal"
	echo ""
	if [[ "$#" -gt "9" ]]; then
		read -p "$t_select_enter" REPLY
	else
		read -n 1 -p "$t_select" REPLY
	fi
	i="$REPLY"
	if [[ $i -gt 0 && $i -le $# ]]; then
		export $v="${!i}"
	else
		export $v=""
	fi
	prchoice=""
}

#LangEngine
language_check() {
        clear
	echo "$t_bannerxiaomi"
	echo "$bluet$t_checking_language $lang$normal"
	lang_add=""
	grep "^export" $makerom/language/english-sr | while read line; do
		line2=$(echo "$line" | cut -d"=" -f1 | gawk '{print $2}')
		if [[ ! $(grep "$line2" $makerom/language/$lang | grep -v "$line2\_") ]]; then
			echo "$line" >> $makerom/language/$lang
			lang_add="1"
                        break
		fi
	done
	if [[ $lang_add = "1" ]]; then
		echo "$t_bannerxiaomi"
		echo -e "$redt$t_lang_added $lang"
		echo "$t_lang_translate$normal"
		echo ""
		echo "$t_enter_continue"
	fi
}

restartlang() {
        clear
	rm -f $makerom/*-sr-chosen
	echo "$t_bannerxiaomi"
	echo -e "$greent$t_reset_language$normal"
	echo ""
	read -p "$t_enter_exit"
        exit 
	continue
        pause
} 

debinstall() {
	debbased=$(which dpkg)
	if [[ $debbased ]]; then
		read -n 1 -p "$t_dep_install_q" reply
		if [[ $reply = "y" ]]; then
			banner
			echo "$bluet$t_dep_install$normal"
			echo ""
			universe=$(grep ^deb /etc/apt/sources.list 2>/dev/null | grep "universe")
			multiverse=$(grep ^deb /etc/apt/sources.list 2>/dev/null | grep "multiverse")
			if [[ ! $universe || ! $multiverse ]]; then
				${usesudo2}add-apt-repository universe >/dev/null
				${usesudo2}add-apt-repository multiverse >/dev/null
			fi
			${usesudo2}apt-get -qq update
			${usesudo2}apt-get -qq -y install $debpkg
			rm -rf depinstall
			debpkg=""
			cd $base
			banner
			echo "${redt}$t_restart$normal"
			echo ""
			read -p "$t_enter_exit"
			exit
		fi
	fi
	echo ""
	echo ""
	read -p "$t_enter_exit"
	rm -rf depinstall
	debpkg=""
	exit
}

#ToolEngine
if [ $? -eq 1 ]; then
    ver=$(echo "$bold$yellowt New update available... $normal")
    echo ""
else
    ver2=$(echo "$bold$yellowt (Actual verion 1.2) $normal")
    echo ""
fi
if [[ $(getconf LONG_BIT) = "64" ]]; then
	adb=$tools/adb64
else
	adb=$tools/adb
fi
if [[ ! $t_select ]]; then
	if [[ $(ls $makerom | grep "sr-chosen") ]]; then
		langfile=$(ls $makerom | grep "sr-chosen" | sed 's/-chosen//')
		if [[ ! -f $makerom/language/$langfile ]]; then
			rm -rf $makerom/$langfile-chosen
			langfile="english-sr"
		fi
		source "$makerom/language/$langfile"
	elif [[ $(ls $makerom/language | wc -l) -gt "1" ]]; then
		source $makerom/language/english-sr
		lang=""
		while [[ ! $lang ]]; do
			echo "$t_bannerxiaomi"
			echo "$greenb$t_title_cho_lang$normal"
			echo ""
			findlang=""
			findlang=$(ls $makerom/language | grep "\-sr")
			choosepr langcho in ${findlang[@]}
			if [[ $REPLY = "q" ]]; then
				exit
			else
				lang="$langcho"
				if [[ ! $lang = "english-sr" ]]; then
					language_check
				fi
				source $makerom/language/$lang
				touch $makerom/$lang-chosen
			fi
		done
	else
		source $makerom/language/english-sr
	fi
fi
if [[ ! $firstrun = "1" ]]; then
        clear
        echo ""
        echo "$bold$redt$t_general_loading$normal"
        echo ""
if [[ $(find $logs/debug.out -type f -size +1111200c 2>/dev/null) ]]; then
    rm -r $logs/debug.out
fi
if [[ $(find $logs/logcat.txt -type f -size +1111200c 2>/dev/null) ]]; then
    rm -r $logs/logcat.txt
fi
	export firstrun="1"
        $userid &
sleep 1
fi
if [[ $(which id) ]]; then
	if [[ $(id -u) = "0" ]]; then
		userid="root"
	fi
elif [[ $EUID = "0" ]]; then
	userid="root"
fi
if [[ $userid = "root" ]]; then
        clear
	echo "$t_bannerxiaomi"
	echo "$redb$bold$t_error_sudo$normal"
	echo ""
	read -p "$bold$redt$t_enter_exit$normal"
	exit
fi
if [[ ! $(echo "$BASH" | grep bash$) ]]; then
        clear
	echo "$t_bannerxiaomi"
	echo -e "$redb$bold$t_error_bash$normal"
	echo ""
	read -p "$bold$redt$t_enter_exit$normal"
	exit
fi
if [[ $(python3 -V | gawk '{print $2}' | sed 's/\.//g') < "350" ]]; then
	echo "$t_bannerxiaomi"
	echo "$redb$bold$t_error_py $(python3 -V | gawk '{print $2}')$normal"
	echo ""
       	read -p "$bold$redt$t_enter_exit$normal"
	exit
fi
##ToolEngineEnd

###############################################################################################################################################

#Menu options
options[0]="$bold$cyant$t_title_bwayne$normal"
options[1]="$bold$cyant$t_title_bjasmine$normal"
options[2]="$bold$cyant$t_title_syncrom$normal"
options[3]="$bold$cyant$t_title_lang$normal $bold$underline$yellowt($langfile)$normal"
options[4]="$bold$cyant$t_title_kernel$normal"
options[5]="$bold$cyant$t_title_adb$normal"
options[6]="$bold$redt$t_title_ccache$normal"
options[7]="$bold$redt$t_title_cleanout$normal"
options[8]="$bold$redt$t_title_devread$normal"

#Actions to take based on selection
function ACTIONS {
    if [[ ${choices[0]} ]]; then
        #Option 1 selected
    clear
    buildwayne 
    exit
    fi
    if [[ ${choices[1]} ]]; then
        #Option 2 selected
    clear 
    buildjasmine
    exit
    fi
    if [[ ${choices[2]} ]]; then
        #Option 3 selected
        clear 
        reposync
        exit
    fi
    if [[ ${choices[3]} ]]; then
        #Option 4 selected
        clear
        restartlang
        exit
    fi
    if [[ ${choices[4]} ]]; then
        #Option 5 selected
        clear
        buildxk
        exit
    fi
    if [[ ${choices[5]} ]]; then
        #Option 6 selected
        clear
        adb
        exit
    fi
    if [[ ${choices[6]} ]]; then
        #Option 7 selected
        clear
        cleancc
        exit
    fi
    if [[ ${choices[7]} ]]; then
        #Option 8 selected
        clear
        cleanout
        exit
    fi
    if [[ ${choices[8]} ]]; then
        #Option 9 selected
        clear
        echo "$t_bannerxiaomi"
        cat README.md
        exit
    fi
}

#Variables
ERROR=""

#Clear screen for menu
clear

#Menu function
function MENU {
    echo "$t_bannerxiaomi"
    echo "$t_title_main $ver2 $ver"
    echo " "
    for NUM in ${!options[@]}; do
        echo "$bold$greent[""${choices[NUM]:- }""]" $(( NUM+1 ))") ${options[NUM]}$normal"
    done
    echo ""
    echo "$blueb$bold$ERROR$normal"
    echo ""
}

#Menu loop
while MENU && read -e -p "$t_select_enter " -n1 SELECTION && [[ -n "$SELECTION" ]]; do
    clear
    if [[ "$SELECTION" == *[[:digit:]]* && $SELECTION -ge 1 && $SELECTION -le ${#options[@]} ]]; then
        (( SELECTION-- ))
        if [[ "${choices[SELECTION]}" == "+" ]]; then
            choices[SELECTION]=""
        else
            choices[SELECTION]="+"
        fi
            ERROR=""
    else
        ERROR="$t_invalid_option $SELECTION"
    fi
done

ACTIONS

###############################################################################################################################################

